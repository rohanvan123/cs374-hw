<h1 style="text-align: center;">Homework 9 - Problem 2</h1>
<p style="text-align: center;">Rohan Vanjani | vanjani3@illinois.edu</p>
<p style="text-align: center;">Rachel Samojedny | rcs6@illinois.edu</p>
<p style="text-align: center;"> Krish Desai | krishvd2@illinois.edu</p>

### 2. a)

2 cases: $G = (V, E)$ is a DAG or $G$ is strongly connected

1. DAG: get the SCC meta graph so we can run the BFS longest path, but we have to account for vertex weights instead of edge weights.

    To do this, we will have to split our vertices to v' and v'' and place the edge between them as the node weight of v for each v in $V$.

    Therefore, we can construct a new graph:
$G' = (V', E')$ where $V' = \{v', v'' for all V\}$, each of these edges weights will be w(v) $\cup$ $E' = \{v' -> v'' forallV \} and \{u''->v' for all edges\}$ 

    This graph can be built in O(V+E) time.

    Using G', we will run the DP linear time BFS longest path and take the max. This runtime is O(V'+E') which is O(V+E) overall runtime.

Each SCC can be treated as if it is a singular SCC so we can use our second case (G is a SCC) on each SCC:

The max eggs is just the sum of all of the weights of the vertices for a SCC, and run the BFS on the metagraph?? confused on this part



Maze (digraph), each node has w(v) eggs located at it.
starting a given node s, has to figure out the max number of eggs they can collect (eggs can only be collected once)

1. get SCCs, meaning each has the total number of eggs for each cycl , so now we have our meta graph that is a DAG

2. run BFS longest path

3. linear time

### 2. b)

Here, we will similarly get our SCC metagraph, but we will add a sentinel node that connects to each source in the metagraph, then run the algorithm from 2a with them choosing which node to follow the sentinel node which will represent their 'starting vertex'. The runtime will be O(V''+E) where this time $V'' = V'\cup \{s'\}$ where s' is the sentinel node, which does not add a significant run time and can be simplified to the same run time of O(V+E).


1. Get SCCs
2. Topological sort the meta graph
3. connect a sentitnal node to each source in our meta graph.
4. then run bfs
5. return any from the source with the longest
6. Do we need to say the actaul source or just the max?

### 2. c)
Our overall problem here is to find the max value picking max k eggs that you can pick from any of the SCC with any combination. For example, you can pick one from each node if the amount of nodes equals k, or you can pick all k from one singular node in the metagraph.
In order to restrict eggs, we need to first create our SCC metagraph and then topolologically sort the graph so that we can utilize the children first and work our way up. We are also going to sort each node in ascending order to easily gain the maxes (O(nlogn) time where n is number of values in a node).We are going to then perform DP with a bottom-up recurrence using the graph itself as our data structure. We will memoize by storing an array of length k+1 at each node, where each index in the array reflects how many eggs are left to fill. For example, at index 0, there are 0 eggs left to grab from that node. Our base case here would be any sink or child of our metagraph, where we will have to initialize it to account for only that node. So at index 0, it will be 0, at index 1, it will pick the singular max value, at index 2 it will add the top 2 max values and so on until k. To simplify into mathematical notation: we will use V' to signify the node we are on as our memoization structure, and V as the array that holds all of the values in the SCC. We will zero index V' for simplification.

        Base Case:  
        if V is a sink:      
                V'[0] = 0 
                V'[1] = V[1]
                ....
                V'[k] = sum(V[1...k])
        Recursive Case:
            V'[0] = max(each outgoing edge'[1])
            ...
            V'[k] = sum(V[1..k]) + max(each outgoing edge'[k + 1])   
            
        We would then return the max of the max value of each source.

This will evaluate from sinks up to source in reverse topological order.

The work at each level is linear, so the most work we have is looping through each node which is |V| and then sorting each node which is O(|V|nlogn), which would be our overall runtime.


you restrict eggs so that they can collect eggs from at most k locations, where k is a parameter you give them.

2d dp array

k different runs for DP algorithm
